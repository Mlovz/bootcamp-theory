## Основы JavaScript

1. Что такое переменные и какие типы данных существуют в JavaScript?
   `Переменные хранят данные, которые можно использовать в коде. Основные типы: number, string, boolean, null, undefined, object, symbol.`

2. В чем разница между var, let и const?
   `var имеет функциональную область видимости, let и const — блочную. const используется для неизменяемых переменных.`

3. Как работают операторы сравнения (== и ===)?
   `== сравнивает значения с приведением типов, === — без приведения (строгое сравнение).`

4. Что такое замыкание и где оно используется?
   `Это функция, которая запоминает свое окружение (переменные) даже после выхода из области видимости.`

5. Как работают функции в JavaScript? В чем разница между функциями, заданными с помощью function и стрелочными функциями (=>)?
   `Обычные функции имеют собственный this, стрелочные наследуют this из контекста, где они объявлены.`

6. Что такое контекст выполнения (this) и как он меняется в зависимости от способа вызова функции?
   `Зависит от способа вызова функции. В методе объекта — это сам объект, в обычной функции — глобальный объект (window в браузере).`

7. Как работают массивы в JavaScript? Как можно добавлять, удалять и находить элементы в массиве?
   `Могут хранить элементы любого типа. Основные методы: push, pop, shift, unshift, map, filter, reduce.`

8. Что такое всплытие (hoisting) в JavaScript? Как это влияет на переменные и функции?
   ` Переменные var и объявления функций поднимаются в начало своей области видимости.`

9. Как работают логические операторы (&&, ||, !)? В каких случаях они могут быть полезны для написания компактного кода?
   `&& возвращает первый ложный или последний истинный операнд. || — первый истинный или последний ложный. ! инвертирует значение.`

10. Что такое временная мёртвая зона (Temporal Dead Zone) и как она связана с let и const?
    `Период между началом блока и инициализацией переменной let или const.`

11. Как работает оператор typeof и какие типы данных он может возвращать?
    `Возвращает строку с типом данных: number, string, boolean, object, function, undefined.`

12. Как работают побитовые операторы в JavaScript? Когда они могут быть полезны?
    `Работают с числами на уровне отдельных битов. Примеры: &, |, ^, ~.`

## Асинхронное программирование

1. Что такое callback-функции? Как они используются в асинхронном коде?
   `Функции, переданные как аргумент и вызываемые после завершения операции.`
2. Что такое промисы (Promises) и как они работают? В чем разница между resolve и reject?
   `Объекты для работы с асинхронными операциями. Имеют состояния: pending, fulfilled, rejected.`
3. Как работает async/await? Чем он лучше использования промисов и callback-функций?
   `Упрощает работу с промисами. await приостанавливает выполнение функции до завершения промиса.`
4. Как обработать ошибки в асинхронном коде?
   `Используйте .catch() с промисами или try/catch с async/await.`
5. Что такое event loop и callback queue? Как они взаимодействуют между собой?
   `Event loop обрабатывает асинхронные операции, отправляя колбэки в очередь выполнения.`
6. Как работает Promise.resolve() и в каких ситуациях его используют?
   `Возвращает промис, который уже завершен успешно.`
7. Что такое microtask и macrotask? Какое значение это имеет в JavaScript?
   `Microtask (например, промисы) выполняются перед macrotask (например, setTimeout).`

8. Как работают async функции в сочетании с try/catch для обработки ошибок?
   `Ошибки в асинхронных функциях можно ловить с помощью try/catch.`

## Работа с DOM

1. Как найти элемент на странице с помощью JavaScript? Какие методы для этого используются?
   `getElementById, querySelector, getElementsByClassName.`
2. Как изменить содержимое элемента на странице?
   `Изменение содержимого: element.textContent, element.innerHTML.`
3. Как добавить или удалить элемент в DOM?
   `Добавление/удаление элементов: appendChild, removeChild, insertBefore.`
4. Как работает делегирование событий? Почему это полезно?
   `Делегирование событий: Назначение обработчика на родительский элемент для обработки событий дочерних элементов.`

## Продвинутые темы

1.  Что такое прототипное наследование? Как оно реализовано в JavaScript?
    `Прототипное наследование: Объекты наследуют свойства и методы от других объектов через цепочку прототипов.`

2.  Как работают классы в JavaScript? Как использовать наследование в классах?
    `Классы: Шаблоны для создания объектов. Поддерживают наследование через ключевое слово extends.`

3.  Что такое модули в JavaScript? Как они помогают структурировать код?
    `Модули: Способы организации кода. Используются import и export.`

4.  Как работают символы (Symbol) в JavaScript?
    `Символы (Symbol): Уникальные и неизменяемые идентификаторы.`

5.  Что такое промисы (Promise.all, Promise.race и Promise.any)?
    `Промисы (Promise.all, Promise.race, Promise.any): Promise.all ждет выполнения всех промисов, Promise.race — первого завершенного, Promise.any — первого успешно завершенного.`

6.  Как работают итераторы и генераторы в JavaScript?
    `Итераторы и генераторы: Итераторы определяют метод next, возвращающий следующую пару {value, done}. Генераторы создают итераторы с помощью function*.`

7.  Что такое Event Loop и как он работает в JavaScript?
    `Event Loop: Механизм, который управляет выполнением асинхронных операций.`

8.  Что такое деструктуризация объектов и массивов? Приведите примеры использования.
    `Деструктуризация: Удобный способ извлечения данных из массивов или объектов. Пример: const {a, b} = obj.`

9.  Как работают шаблонные строки в JavaScript? Как они отличаются от обычных строковых литералов?Шаблонные строки: Строки с поддержкой интерполяции значений через ${}.
    `Шаблонные строки: Строки с поддержкой интерполяции значений через ${}.`

10. Что такое rest и spread операторы? Приведите примеры использования.
    `rest и spread операторы: rest собирает остаток аргументов, spread — разворачивает массив или объект.`

11. Как работает метод Object.assign() и как он отличается от оператора ... (spread)?
    `Object.assign(): Копирует свойства из одного или более объектов в целевой объект. Оператор ... (spread) делает то же.`

12. Что такое прокси (Proxy) в JavaScript? Как они могут быть использованы для создания более гибких объектов?
    `Прокси (Proxy): Позволяют перехватывать и изменять поведение операций над объектами (например, чтение или запись свойств).`

## Работа с функциями

1.  Что такое каррирование (currying) и как его использовать в JavaScript?
    `Каррирование: Преобразование функции с несколькими аргументами в последовательность функций, каждая из которых принимает один аргумент.`
2.  Как работает мемоизация функций? Как её можно реализовать?
    `Мемоизация: Кэширование результатов функции для улучшения производительности.`
3.  В чем разница между функциями первого класса и высшего порядка?
    `Функции первого класса и высшего порядка: Первого класса — функции можно присваивать переменным. Высшего порядка — функции, принимающие или возвращающие другие функции.`
4.  Что такое самовызывающаяся функция (IIFE)? Какую роль она играет в коде?
    `Самовызывающаяся функция (IIFE): Функция, которая вызывается сразу после определения. Обычно используется для создания локального контекста.`

## Работа с данными

1.  Как работают методы массивов, такие как map, filter, reduce? Приведите примеры их использования.
    `Методы массивов (map, filter, reduce): map создает новый массив с результатами вызова функции для каждого элемента, filter возвращает массив элементов, прошедших проверку, reduce сводит массив к одному значению.`
2.  Как можно проверить, является ли значение массивом?
    `Проверка на массив: Array.isArray(value).`
3.  Как можно объединить несколько массивов в один? Приведите разные способы.
    `Объединение массивов: concat, spread operator.`
4.  Что такое Set и Map в JavaScript? Как они отличаются от массивов и объектов?
    `Set и Map: Set — коллекция уникальных значений, Map — коллекция пар ключ-значение.`
5.  Как работают слабые коллекции (WeakMap, WeakSet) и в чем их преимущество?
    `Слабые коллекции (WeakMap, WeakSet): Слабые ссылки на объекты, позволяющие сборку мусора.`

## Работа с событиями

1.  Как работают события в JavaScript? В чем разница между фазами захвата и всплытия?
    `События и фазы: События проходят через три фазы: захват, цель, всплытие. Обработчики могут быть добавлены на любой фазе.`
2.  Что такое событие event.preventDefault() и когда его нужно использовать?
    `event.preventDefault(): Останавливает действие события по умолчанию (например, отправку формы).`
3.  Как работает event.stopPropagation() и когда его применяют?
    `event.stopPropagation(): Останавливает всплытие события вверх по дереву DOM.`
4.  Как можно добавить и удалить обработчики событий в JavaScript?
    `Добавление/удаление обработчиков: addEventListener, removeEventListener.`

## Вопросы на понимание кода

1. Чем отличается вызов функции foo.call(context, arg1, arg2) от foo.apply(context, [arg1, arg2])?
   `call vs apply: call передает аргументы по одному, apply — массивом.`
2. Как работает оператор new? Что происходит при вызове new?
   `Оператор new: Создает новый объект и связывает его с прототипом функции.`
3. Как работает оператор ?? (nullish coalescing)? В чем его отличие от ||?
   `Оператор ??: Возвращает правый операнд, если левый null или undefined, иначе — левый.`
4. Как работает Object.freeze() и как это влияет на объекты?
   `Object.freeze(): Делает объект неизменяемым (нельзя добавлять/удалять/изменять свойства).`
5. Что произойдет при попытке удалить свойство из объекта, если объект был создан с Object.defineProperty() и имеет конфигурацию configurable: false?
   `Object.defineProperty и configurable: false: Свойство нельзя удалить или изменить его конфигурацию.`

## Практические задачи

1. Реализуйте функцию, которая будет дожидаться выполнения нескольких промисов и возвращать результат только тех, которые выполнились успешно.

```
async function waitForSuccess(promises) {
    const results = await Promise.allSettled(promises);
    return results
        .filter(result => result.status === "fulfilled")
        .map(result => result.value);
}

// Пример использования
const promises = [
    Promise.resolve(1),
    Promise.reject(new Error("ошибка")),
    Promise.resolve(3)
];

waitForSuccess(promises).then(console.log); // [1, 3]

```

2. Напишите функцию для глубокого клонирования объекта.

```
function deepClone(obj) {
    if (obj === null || typeof obj !== "object") {
        return obj;
    }

    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item));
    }

    const clone = {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            clone[key] = deepClone(obj[key]);
        }
    }
    return clone;
}

// Пример использования
const original = { a: 1, b: { c: 2 } };
const copy = deepClone(original);
console.log(copy); // { a: 1, b: { c: 2 } }

```

3. Реализуйте debounce функцию.

```
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

// Пример использования
const log = debounce(() => console.log("Hello"), 300);
log();
log();
log(); // Только одно "Hello" будет выведено через 300ms после последнего вызова

```

4. Напишите собственную реализацию функции bind.

```
Function.prototype.myBind = function(context, ...args) {
    const func = this;
    return function(...newArgs) {
        return func.apply(context, args.concat(newArgs));
    };
};

// Пример использования
function greet(greeting, punctuation) {
    console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: 'Alice' };
const boundGreet = greet.myBind(person, 'Hello');
boundGreet('!'); // Hello, Alice!

```

5. Реализуйте функцию, которая будет дебаунсить вызовы другой функции (т.е., ограничивать частоту её вызовов).

```
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

```

6. Реализуйте функцию, которая выполнит глубокое слияние двух объектов.

```
function deepMerge(target, source) {
    for (let key in source) {
        if (source.hasOwnProperty(key)) {
            if (typeof source[key] === "object" && source[key] !== null) {
                if (!target[key]) target[key] = Array.isArray(source[key]) ? [] : {};
                deepMerge(target[key], source[key]);
            } else {
                target[key] = source[key];
            }
        }
    }
    return target;
}

// Пример использования
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { b: { d: 3 }, e: 4 };
const merged = deepMerge(obj1, obj2);
console.log(merged); // { a: 1, b: { c: 2, d: 3 }, e: 4 }

```

7. Напишите функцию для сравнения двух массивов на предмет их равенства.

```
function arraysEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) return false;
    for (let i = 0; i < arr1.length; i++) {
        if (Array.isArray(arr1[i]) && Array.isArray(arr2[i])) {
            if (!arraysEqual(arr1[i], arr2[i])) return false;
        } else if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}

// Пример использования
console.log(arraysEqual([1, 2, [3, 4]], [1, 2, [3, 4]])); // true
console.log(arraysEqual([1, 2, 3], [1, 2, 4])); // false

```

8. Создайте свой аналог метода Array.prototype.reduce().

```
function myReduce(array, callback, initialValue) {
    let accumulator = initialValue !== undefined ? initialValue : array[0];
    let startIndex = initialValue !== undefined ? 0 : 1;

    for (let i = startIndex; i < array.length; i++) {
        accumulator = callback(accumulator, array[i], i, array);
    }

    return accumulator;
}

// Пример использования
const sum = myReduce([1, 2, 3, 4], (acc, val) => acc + val, 0);
console.log(sum); // 10

```

## Оптимизация и безопасность

1. Какой подход лучше для обработки больших массивов данных?
   `Обработка больших массивов: Используйте методы map, filter, reduce, разделение на чанки, Web Workers.`
2. Что такое debounce и throttle и когда их следует использовать?
   `debounce и throttle: debounce откладывает выполнение функции, throttle ограничивает частоту выполнения.`
3. Какие меры безопасности нужно принимать при работе с пользовательским вводом?
   `Безопасность: Всегда проверяйте и очищайте пользовательский ввод, используйте escape для данных.`
4. Что такое CORS и как он работает?
   `CORS: Механизм безопасности, позволяющий контролировать доступ к ресурсам из разных источников.`

## Дополнительные вопросы по архитектуре и паттернам

1. Как можно организовать модульность кода в JavaScript? Какие существуют подходы?
   `Модульность кода: Используйте модули ES6 (import, export) или IIFE для изоляции кода.`
2. Что такое шаблон проектирования "Модуль" (Module Pattern)?
   `Шаблон "Модуль": Создает приватные и публичные методы/переменные в замыкании.`
3. Как реализовать singleton на JavaScript? Какие плюсы и минусы у этого подхода?
   `Singleton: Паттерн, ограничивающий создание экземпляра класса одним объектом.`
4. Что такое “Observer Pattern” и как его можно реализовать в JavaScript?
   `Observer Pattern: Объекты могут подписываться на события и быть уведомленными об изменениях.`
